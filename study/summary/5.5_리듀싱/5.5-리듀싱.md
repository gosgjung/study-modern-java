# 5.5 리듀싱

> 개인적으로 리듀싱을 가장 잘 설명하는 용어는 '누적'이라는 단어라고 생각한다. 책에는 누적이라는 말이 없지만, 주관적인 의견으로는 '누적'이라는 단어가 더 많이 와닿는다. 아마도 javascript 를 통해서 reduce를 먼저 접해서 그런 것일지도 모르겠다.  
>
> (javascript 에서 reduce함수의 명세를 표현할 때 accumulator 라는 단어가 쓰이기도 했었다.)



- '메뉴에서 칼로리가 가장 높은 요리는?'
- '메뉴에서 모든 음식의 칼로리의 합계는?'

과 같은 연산을 수행할 때 **리듀싱연산**을 사용한다. **질의를 수행할 때 Integer 와 같은 결과가 나올 때 까지 스트림의 모든 요소를 반복적으로 처리하는 것**을 **리듀싱 연산**이라고 한다. 리듀싱 연산은 모든 스트림 요소를 처리해서 값으로 도출한다.  

함수형 프로그래밍 언어에서의 용어로는 이 과정이 마치 종이를 작은 조각이 될 때까지 접는 것과 유사하다는 의미로 **폴드(fold)**라고 부르기도 한다.



# 5.5.1 요소의 합

## 예제

아래의 sum 기능 역할을 하는 예제가 있다.

```java
int sum = 0;
for(int x : numbers){
  sum += x;
}
```



위의 연산의 특징을 정리해보자. 

- numbers 의 각 요소는 결과에 반복적으로 더해진다. 
- 리스트에서 하나의 숫자가 남을 때까지 reduce 과정을 반복한다.

그리고 사용한 파라미터는 아래와 같이 두가지이다.

- sum 변수의 초깃값 0
- 리스트의 모든 요소를 조합하는 연산(+)



위의 예제를 간단하게 reduce 함수를 이용해서 만들어보면 아래와 같다.

```java
int sum = numbers.stream().reduce(0, (a,b) -> a+b);
```



## reduce () 함수의 형태

reduce() 함수는 두 개의 인수를 갖는다.

- 초깃값 0
- 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator\<T\>
  - 예제에서는 람다 표현식 (a,b) -> a + b 를 사용한다.

위의 예제에서는 아래와 같이 덧셈을 하는 리듀스 함수를 작성했었다.

> int sum = numbers.stream().reduce(0, (a,b) -> a+b);

위와 같은 덧셈을 누적해가면서 합계를  구하는 함수는 모든 요소의 곱을 구하는 함수로 아래와 같이 표현하는 것 역시 가능하다.

> int sum = numbers.stream().reduce(0, (a,b) -> a*b);

손그림 추가하기 (책 171 page, 전자책 172page)



## 초기값이 없을 때의 reduce 함수

초깃값을 받지 않도록 오버로딩 된 reduce 함수도 존재한다. 초깃값을 받는 reduce (0, BinaryOperator\<T\> operator) 와는 다르게 초깃값을 받지 않는 reduce 함수는 Optional\<T\> 를 반환한다. 

초깃값을 받지 않을 때의 reduce 함수는 아래와 같은형태를 가지고 있다.

```java
Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a + b));
```



# 5.5.2 최댓값과 최솟값

reduce 함수는 최댓값, 최솟값을 구하는데에도 사용 가능하다. reduce를 이용해서 스트림에서 최댓값과 최솟값을 찾는 방법은 아래와 같다. 위에서 살펴봤듯이 reduce 는 두 인수를 받는다.

- 초깃값
- 스트림의 두 요소를 합쳐서 하나의 값으로 만드는 데 사용할 람다



이제 이 원리를 이용해서 최댓값, 최솟값을 구하는 예제를 풀어보면 아래와 같다.

**최댓값**

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

또는 아래와 같이 변경 가능하다.

```java
Optional<Integer> max = numbers.stream().reduce((x, y) -> x>y ? x:y);
```



**최솟값**

```java
Optional<Integer> min = numbers.stream().reduce(Integer::min);
```

또는 아래와 같이 변경 가능하다.

```java
Optional<Integer> min = numbers.stream().reduce((x, y) -> x<y ? x:y);
```



# 퀴즈 5.3

map 과 reduce 메서드를 이용해서 스트림의 요리 갯수를 계산하시오.

```java
int count = menu.stream().map(d -> 1).reduce(0, (a,b) -> a+b);
```

- 맵 (map())으로 리스트의 각 원소를 1로 변환하였다.
- 그리고 reduce로 덧셈 누적계산을 하는 코드를 작성하였다.

map과 reduce 를 연결하는 기법을 맵 리듀스 (map-reduce) 패턴이라고 한다. 쉽게 병렬화 할 수 있는 특징 덕분에 구글이 웹 검색에 적용하면서 유명해졌다. 4 장에서는 count 로 스트림 요소를 세는 방법을 살펴봤었다.

```java
long count = menu.stream().count();
```



# reduce 메서드의 장점과 병렬화

일반 for 문으로 합계를 구하는 것과 reduce를 이용해서 합계를 구하는 것의 차이점은 무엇일까? 일반 반복문을 사용할 때에 비해 reduce 메서드를 쓰는 것으로 인해 얻을 수 있는 장점은 병렬로직 내에서 합계 등의 값을 구하는 데에 유리하다는 점이다. for 문의 경우 sum 이라는 변수를 외부에 공유해서 사용해야 하는데, 이 것은 스레드에 안전하지 못하다. 

final 키워드를 통해 immutable, 불변상태를 통해 스레드 환경에서 누적값을 구해야 병렬 스레드에서 안전하다. 나중에 정리... 어휴













