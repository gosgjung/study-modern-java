

# 목차

[TOC]

------



# 5.5 리듀싱

> 개인적으로 리듀싱을 가장 잘 설명하는 용어는 '누적'이라는 단어라고 생각한다. 책에는 누적이라는 말이 없지만, 주관적인 의견으로는 '누적'이라는 단어가 더 많이 와닿는다. 아마도 javascript 를 통해서 reduce를 먼저 접해서 그런 것일지도 모르겠다.  
>
> (javascript 에서 reduce함수의 명세를 표현할 때 accumulator 라는 단어가 쓰이기도 했었다.)



- '메뉴에서 칼로리가 가장 높은 요리는?'
- '메뉴에서 모든 음식의 칼로리의 합계는?'

과 같은 연산을 수행할 때 **리듀싱연산**을 사용한다. **질의를 수행할 때 Integer 와 같은 결과가 나올 때 까지 스트림의 모든 요소를 반복적으로 처리하는 것**을 **리듀싱 연산**이라고 한다. 리듀싱 연산은 모든 스트림 요소를 처리해서 값으로 도출한다.  

함수형 프로그래밍 언어에서의 용어로는 이 과정이 마치 종이를 작은 조각이 될 때까지 접는 것과 유사하다는 의미로 **폴드(fold)**라고 부르기도 한다.  



# 5.5.1 요소의 합

## 예제

아래의 sum 기능 역할을 하는 예제가 있다.

```java
int sum = 0;
for(int x : numbers){
  sum += x;
}
```



위의 연산의 특징을 정리해보자. 

- numbers 의 각 요소는 결과에 반복적으로 더해진다. 
- 리스트에서 하나의 숫자가 남을 때까지 reduce 과정을 반복한다.

그리고 사용한 파라미터는 아래와 같이 두가지이다.

- sum 변수의 초깃값 0
- 리스트의 모든 요소를 조합하는 연산(+)



위의 예제를 간단하게 reduce 함수를 이용해서 만들어보면 아래와 같다.

```java
int sum = numbers.stream().reduce(0, (a,b) -> a+b);
```



## reduce () 함수의 형태

reduce() 함수는 두 개의 인수를 갖는다.

- 초깃값 0
- 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator\<T\>
  - 예제에서는 람다 표현식 (a,b) -> a + b 를 사용한다.

위의 예제에서는 아래와 같이 덧셈을 하는 리듀스 함수를 작성했었다.

> int sum = numbers.stream().reduce(0, (a,b) -> a+b);

위와 같은 덧셈을 누적해가면서 합계를  구하는 함수는 모든 요소의 곱을 구하는 함수로 아래와 같이 표현하는 것 역시 가능하다.

> int sum = numbers.stream().reduce(0, (a,b) -> a*b);

손그림 추가하기 (책 171 page, 전자책 172page)



## 초기값이 없을 때의 reduce 함수

초깃값을 받지 않도록 오버로딩 된 reduce 함수도 존재한다. 초깃값을 받는 reduce (0, BinaryOperator\<T\> operator) 와는 다르게 초깃값을 받지 않는 reduce 함수는 Optional\<T\> 를 반환한다. 

초깃값을 받지 않을 때의 reduce 함수는 아래와 같은형태를 가지고 있다.

```java
Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a + b));
```



# 5.5.2 최댓값과 최솟값

reduce 함수는 최댓값, 최솟값을 구하는데에도 사용 가능하다. reduce를 이용해서 스트림에서 최댓값과 최솟값을 찾는 방법은 아래와 같다. 위에서 살펴봤듯이 reduce 는 두 인수를 받는다.

- 초깃값
- 스트림의 두 요소를 합쳐서 하나의 값으로 만드는 데 사용할 람다



이제 이 원리를 이용해서 최댓값, 최솟값을 구하는 예제를 풀어보면 아래와 같다.

**최댓값**

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

또는 아래와 같이 변경 가능하다.

```java
Optional<Integer> max = numbers.stream().reduce((x, y) -> x>y ? x:y);
```



**최솟값**

```java
Optional<Integer> min = numbers.stream().reduce(Integer::min);
```

또는 아래와 같이 변경 가능하다.

```java
Optional<Integer> min = numbers.stream().reduce((x, y) -> x<y ? x:y);
```



# 퀴즈 5.3

map 과 reduce 메서드를 이용해서 스트림의 요리 갯수를 계산하시오.

```java
int count = menu.stream().map(d -> 1).reduce(0, (a,b) -> a+b);
```

- 맵 (map())으로 리스트의 각 원소를 1로 변환하였다.
- 그리고 reduce로 덧셈 누적계산을 하는 코드를 작성하였다.

map과 reduce 를 연결하는 기법을 맵 리듀스 (map-reduce) 패턴이라고 한다. 쉽게 병렬화 할 수 있는 특징 덕분에 구글이 웹 검색에 적용하면서 유명해졌다. 4 장에서는 count 로 스트림 요소를 세는 방법을 살펴봤었다.

```java
long count = menu.stream().count();
```



# reduce 메서드의 장점과 병렬화

위와 같은 반복문에서 합계를 구하는 패턴을 가변 누적자 패턴(mutable accumulator pattern)이라고 하는 것 같다. **반복문에서 값을 누적해가며 합계를 구하는 것**과 **reduce를 이용해 합계를 구하는 것**은 **"병렬화가 되었는지 아닌지"**에 대한 차이점이 있다. 일반 for문을 병렬 로직에서 구현하려면 뮤텍스 조건변수를 잘 설정해야 한다. 불가능 한 것은 아니다. 대신 락을 잘 걸어야 하는데 이것은 Java 에서는 sychronized 라고 하는 키워드로 락을 건다. 하지만 락을 거는 동안에도 어느 정도의 손실이 있다는 점 역시 생각해야 한다.  

  

이와 같은 for 문에서의 합을 구하는 로직을 병렬화하려면 

- 입력을 분할
- 분할된 입력을 덧셈
- 더한 값을 모두 합침

위의 세 연산을 수행하여야 한다. 이와 같은 작업들은 7장의 포크/조인 프레임워크(fork/join framework)를 이용하여 구현가능하다. 7장에서 배우게 될 내용이지만 합계를 구하는 식을 병렬로 수행되는 예제를 표현해보면 아래와 같다.

```java
int sum = numbers.parallelStream().reduce(0, Integer::sum);
```



위와 같은 parallelStream 코드를 사용할 때는 아래의 조건을 충족시켜야 한다.

- reduce 에 넘겨주는 람다의 상태가 변하지 않아야 한다.
  - 람다는 변수에 할당할 수도 있기 때문에, 람다식이 변하게 되면 병렬수행에 대한 연산이 바뀌기 때문이다.
  - 이런 이유로 병렬 stream 식에서 람다식은 final로 선언해서 넘겨주면 될 것 같다.
- 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 않는 구조여야 한다.  



# 스트림 연산 : 상태 없는 연산과 상태 있는 연산

> - 상태없는 연산 (stateless operation)
> - 상태있는 연산 (stateful operation)



## map, filter

map, filter 와 같은 연산은 입력 스트림에서 컬렉션 내의 각 요소를 받아서 0 또는 결과값(boolean 등등)을 출력 스트림으로 내보낸다. 이와 같은 연산은 각 요소를 받아 특정 조건식에 따라 특정 결과만을 전달하면 되기 때문에 내부에 상태를 저장하고 있을 필요가 없다. 따라서 이와 같은 연산들을 보통 내부 **상태를 갖지 않는 연산(stateless operation)**이라고 부른다.  

  

## reduce, sum, max

reduce, sum, max 와 같은 연산은 내부에 누적할 상태가 필요하다. 위에서 사용했던 예제에서는 int, double 등의 타입들을 내부 상태로 사용했다. 스트림에서 처리하는 요소의 수와 관계없이 내부 상태의 크기는 **한정(bounded)**되어 있다. stream api 내부에 누적할 값의 상태를 가지고 연산을 수행한다. 따라서 **reduce, sum, max 는 상태가 있는 연산**이다.



## sorted, distinct

스트림의 요소를 정렬하거나 중복을 제거하는 연산인 sorted, distinct 는 정렬,중복 제거 연산을 수행할 때 과거의 이력을 알아야 한다. 데이터 스트림의 크기가 무한이거나, 엄청나게 클경우 정렬을 하는데에 문제가 생길수도 있다. 요소를 정렬하려면 연산을 수행하려는 전체 컬렉션을 어느정도는 버퍼로 저장하고 있어야한다. 따라서 **sorted, distinct 연산은 상태가 있어야 하는 연산**, 즉 **상태가 있는 연산**이다.   

