# 16.4-16.5 비동기 작업 파이프라인 만들기

예제 소스에 대한 설명은 16.4-예제코드-정리.md 에 정리해두었다.<br>

<br>

## 목차

- [참고자료](#참고자료)<br>
- [Overview](#overview)<br>
- [문제의 코드](#문제의-코드)<br>
  - [출력결과](#출력결과)<br>
- [커스텀 Executor 생성하기](#커스텀-executor-생성하기)<br>
- [두 가지 비동기 연산을 thenCompose 로 비동기 파이프라인으로 만들어 처리해보기](#두-가지-비동기-연산을-thencompose-로-비동기-파이프라인으로-만들어-처리해보기)<br>
  - [call-flow](#call-flow)<br>
  - [테스트코드 - thenCompose 를 이용한 비동기파이프라인](#테스트코드---thenCompose-를-이용한-비동기-파이프라인)<br>
  - [1) supplyAsync(Supplier, Executor)](#1--supplyasync(supplier--Executor-))<br>
  - [2) thenApply(Funciton)](#2--thenapply-funciton-)<br>
  - [3) thenCompose(Function)](#3--thencompose-function-)<br>

<br>

## 참고자료

- [모던 자바 인 액션](http://www.yes24.com/Product/Goods/77125987)<br>
- [docs.oracle.com/javase - CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)
- [devidea.tistory.com/34 - CompletableFuture 정리](https://devidea.tistory.com/34)<br>

<br>

## Overview

어떤 내용을 배우게 될지 정리하지 않고, 무작정 독자가 따라서 읽게끔 하는 것은 조금은 불친절한게 아닐까하는 생각이 들었다. [모던 자바 인 액션](http://www.yes24.com/Product/Goods/77125987) 책이 실제로 그렇다. 일단 이번 챕터를 정리하기 전에 어떤 메서드들을 다루게 되는지 등을 먼저 문서 초입에 요약을 잘 해놓아야 할 것 같다.<br>

<br>(정리 필요!!!)

- `CompletableFuture::supplyAsync(Supplier<U> supplier)` <br>
  - Returns a new CompletableFuture that is asynchronously completed by a task running in the [`ForkJoinPool.commonPool()`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--) with the value obtained by calling the given Supplier.
- `CompletableFuture::supplyAsync(Supplier<U> supplier, Executor executor)` <br>
  - Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.
- `CompletableFuture::thenApply` <br>
  - `thenApply(Function \<? super T, ? extends U\> fn)` <br>
  - Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function.
- `CompletableFuture::thenCompose` <br>
  - `thenCompose(Function\<? super T, extends CompletionStage\<U\>\> fn)` <br>
  - Returns a new CompletionStage that, when this stage completes normally, is executed with this stage as the argument to the supplied function.
- `CompletableFuture::thenCombine` <br>
  - `thenCombine(CompletionStage\<? etends U\> other, BiFunction\<? super T, ? super U, ? extends V\> fn)` <br>
  - Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function.
- `orTimeout` , `completeOnTimeout` <br>
  - 타임아웃 효과적으로 사용하기<br>

<br>

## 문제의 코드

가게 5개에 대해서 "myphone" 이라는 물건의 가격과 할인율을 조회한다. 이 때 조회하는 함수들은 아래와 같다.<br>

- 처리속도가 1초인 getPrice(String product)<br>
- 처리속도가 1초인 applyDiscount(Quote qoute)<br>

<br>

기대되는 수행시간은 10000ms, 즉, 10초 가량이다.

```java
package io.study.modernjavainaction.ch16;

import io.study.modernjavainaction.ch16.discount.Discount;
import io.study.modernjavainaction.ch16.discount.Quote;
import io.study.modernjavainaction.ch16.shop.Shop;
import java.util.*;
import java.util.stream.Collectors;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class AsyncPipelineTest_16_4 {

	List<Shop> shops = Arrays.asList(
		new Shop("광명시 삼성센터"),
		new Shop("강남구 삼성센터"),
		new Shop("분당구 삼성센터"),
		new Shop("안양시 삼성센터"),
		new Shop("수원시 삼성센터")
	);

	public List<String> findPrices(String product){
		return shops.stream()
			.map(shop -> shop.getPrice(product))
			.map(Quote::parse)
			.map(Discount::applyDiscount)
			.collect(Collectors.toList());
	}

	@DisplayName("문제예제1_동기식으로_값_조회와_할인율계산을_한꺼번에_수행하기")
	@Test
	void 문제예제1_동기식으로_값_조회와_할인율계산을_한꺼번에_수행하기(){
		long start = System.nanoTime();
		List<String> results = findPrices("myphone");
		long duration = (System.nanoTime() - start) / 1000000;
		System.out.println("[완료] " + duration + " ms");
	}
}
```

<br>

실제로 최종적으로 수행되는 시간은 10초(10000ms)가 소요되게 된다.<br>

### 출력결과

```plain
[완료] 10064 ms
```

<br>

## 커스텀 Executor 생성하기

[모던 자바 인 액션](http://www.yes24.com/Product/Goods/77125987) 에서 제공하는 Executor 는 스레드 풀 등의 크기 등에 대해 크게 의미를 부여해 만들어진 Executor는 아니지만, 책에서 직접 사용한 커스텀 Executor 를 사용해봤다.<br>

```java
private final Executor executor =
  Executors.newFixedThreadPool(Math.min(shops.size(), 100), new ThreadFactory(){
    public Thread newThread(Runnable r){
      Thread t = new Thread(r);
      t.setDaemon(true);
      return t;
    }
  });
```

<br>

스레드 풀의 개념에 대해서는 16.3 에서 따로 정리할 예정이다.<br>

<br>

## 두 가지 비동기 연산을 thenCompose 로 비동기 파이프라인으로 만들어 처리해보기

[모던 자바 인 액션](http://www.yes24.com/Product/Goods/77125987) 에서는 이 부분을 16.4.3 에서 3 페이지 가량에 걸처 설명하고 있다. 이 내용을 더 줄여서 요약할 수 있을지는 아직 자신이 없지만 정리를 시작해보려 한다.<br>

<br>

### call-flow

구글 독스의 파워포인트에서 그려본 그림이다. 잘 그리지는 못했다. 그림실력이 좋지 않다. 전체적인 call-flow 는 아래와 같다.<br>

![이미지](./img/16.4-CALLFLOW-THEN-COMPOSE.png)

<br>

### 테스트코드 - thenCompose 를 이용한 비동기 파이프라인

```java
package io.study.modernjavainaction.ch16;

public class AsyncPipelineTest_16_4 {

	List<Shop> shops = Arrays.asList(
		new Shop("광명시 삼성센터"),
		new Shop("강남구 삼성센터"),
		new Shop("분당구 삼성센터"),
		new Shop("안양시 삼성센터"),
		new Shop("수원시 삼성센터")
	);

	private final Executor executor =
		Executors.newFixedThreadPool(Math.min(shops.size(), 100), new ThreadFactory(){
			public Thread newThread(Runnable r){
				Thread t = new Thread(r);
				t.setDaemon(true);
				return t;
			}
		});
  
	@DisplayName("예제2_두가지_비동기_연산을_thenCompose()_메서드를_이용해_파이프라인으로_만들어서_처리해보기")
	@Test
	void 예제2_두가지_비동기_연산을_thenCompose_메서드를_이용해_파이프라인으로_만들어서_처리해보기(){
		long start = System.nanoTime();
		String product = "myphone";

		List<CompletableFuture<String>> priceStrFutures = shops.stream()
			.map(shop -> CompletableFuture.supplyAsync(() -> shop.getPrice(product), executor))
			.map(future -> future.thenApply(Quote::parse))
			.map(future -> future.thenCompose(
				quote -> CompletableFuture.supplyAsync(
					() -> Discount.applyDiscount(quote), executor)
			))
			.collect(Collectors.toList());

		priceStrFutures.stream()
			.map(CompletableFuture::join)
			.collect(Collectors.toList());

		long duration = (System.nanoTime() - start) / 1000000;
		System.out.println("[완료] " + duration + " ms");
	}
}
```

<br>

출력결과

```plain
[완료] 2056 ms
```

 순차적으로 모두 처리할 경우 10초가 걸려야 하는데, 2초 만에 처리가 완료되었다. 아래에서부터는 위의 코드를 설명하면서 CompletableFuture에서 제공하는 API에 대해서도 정리해볼 예정이다.<br>

<br>

### 1) supplyAsync(Supplier, Executor)

> Executor 객체로 Supplier 람다를 실행시켜 CompletableFuture 태스크를 비동기적으로 완료시킨다.<br>

<br>

CompletableFuture의 `supplyAsync` 는 이전에서 살펴봤었었다. `supplyAsync`  의 역할을 간단하게 요약해보면 아래와 같다.<br>

- supplyAsync의 역할은 아래의 두가지이다.
  - `CompletableFuture` 인스턴스를 생성하는 팩토리 메서드 역할<br>
  - 파라미터로 Supplier 람다를 받아서 스레드가 어떤 역할을 할지 기술한다.<br>
  - Executor 인스턴스를 전달하는 오버로딩된 메서드 역시 존재하는데, 이런 메서드의 경우는 전달받은 Executor 객체로 비동기적으로 CompletableFuture 태스크를 완료시킨다.<br>
- supplyAsync는 CompletableFuture 클래스 내에서 아래의 두가지 형태의 메서드 들로 오버로딩되어 있다. <br>
  - `supplyAsync (Supplier <U> supplier)` <br>
  - `supplyAsync (Supplier <U> supplier, Executor executor)` <br>
    - `supplyAsync (Supplier <U> supplier, Executor executor)`  의 경우 직접 커스터마이징한 Executor 를 인자로 전달해서 지정할 수 있다.<br>

<br>

위에서 사용한 예제에서 supplyAsync 를 통해 completableFuture 인스턴스를 생성하는 부분은 아래와 같다.<br>

![이미지](./img/16.4-SUPPLY-ASYNC.png)

<br>

아래의 두개의 태스크를 supplyAsync를 통해 CompletableFuture 인스턴스로 생성했다.<br>

- 가격 조회 (shop.getPrice(String product)) <br>
- 할인율 조회 (Discount.applyDiscount(quote)) <br>

<br>

이 작업들은 2초내에 수행된다. 그리고 이 CompletableFuture 인스턴스는 shops의 갯수인 5개가 생성된다.<br>

<br>

### 2) thenApply(Function)

> 참고) [docs.oracle.com/.../CompletableFuture/thenApply](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#thenApply-java.util.function.Function-)<br>
>
> Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function.<br>
>
> (CompletionStage 는 CompletableFuture 클래스가 구현하는 인터페이스명이다.)<br>
>
> 원서에는 위와 같이 적혀있고, 한글로 번역해보니 뜻이 너무 이상했다. 단순히 번역을 받아적기보다는 되도록이면 실용적으로 예제 기반으로 정리하는 것이 맞을 것 같다는 생각이 들었다. (사람이 아닌 기계가 말하는 것 같은 느낌...)<br>

<br>

일단, 책에 나온 예제에서 thenApply 구문이 적용된 부분을 보자.

![이미지](./img/16.4-THEN-APPLY.png)

thenApply 메서드는 CompletableFuture가 끝날 때 까지 블록하지 않는다. 이점에 주의해야 한다.<br>

약간은 야매같은 요약이지만, thenApply는 CompletableFuture\<T\> 를 CompletableFuture\<A'\> 로 바꿔주는 역할을 한다. (제너릭 타입을 바꾸는 역할, 변환하는 역할)<br>

<br>

어떻게든 thenApply 메서드의 기능을 요약해서 설명하려 했는데, 쉽지 않았다. 그래서 그냥 위의 예제를 요약하는 것으로 설명을 대체하는 것이 나을 것 같다.<br>

- 먼저 CompletableFuture.supplyAsync() 를 통해 CompletableFuture\<String\> 타입의 인스턴스를 생성하고 있다. <br>
  - 가격을 문자열로 반환하는 가격 조회 작업인 `getPrice(string)` 을 supplyAsync로 비동기 작업으로 처리되도록 비동기 스레드를 생성했다.<br>
- `CompletableFuture<String> -> CompletableFuture<Quote>` <br>
  - 이 인스턴스는 두 번째 map 에서 thenApply 하고 있다. Quote 클래스의 parse 는 `parse(String price) : Quote` 와 같은 형식을 지니고 있다.<br>
  - thenApply 내의 인자는 Function \<T, R\> 객체인데, 위 예제에서는 T(Type)=String, R(Return)=Quote 로 지정했기 때문에 thenApply 함수 내부구현에서는 R(Return) 에 해당하는 Quote 타입으로 변환된 CompletableFuture\<Quote\> 로 변환된다.<br>
  - 참고) Quote 클래스의 parse 함수는 가격을 문자열로 받아 Quote 인스턴스를 반환한다. ([소스 참고](https://github.com/soongujung/modern-java-in-action/blob/develop/example/src/test/java/io/study/modernjavainaction/ch16/discount/Quote.java)) <br>

<br>

### 3) thenCompose(Function)

일단, thenCompose는 두 개의 비동기 연산을 파이프라인으로 만들 때에 사용한다. 첫번째 연산의 결과를 두번째 연산으로 전달한다.<br>

thenCompose 내에 인자로 전달되는 Function\<T, R\> 은 

- `T(Type)` 으로 첫번째 CompletableFuture를 받는다. 
- 그리고 반환되는 값인 `R(Return)`로는 두번째 CompletableFuture를 반환한다. 

두번째 CompletableFuture 는 첫번째 CompletableFuture 의 결과를 계산의 입력으로 사용한다.<br>

이때 shops 를 stream 으로 순회하면서 여러 상점에서 thenCompose를 통해 Quote 를 얻어내는 동안, 미래의 특정 시점에 Future::join 이 호출되기 전까지 다른 동작을 수행할 수 있다.<br>(다른 UI 동작, 계산동작 등등 여러가지... 양치하면서 스마트폰 보고 이런 느낌? 양치가 끝나는 시점이 Future::join 이 호출되는 시점이다. 모든 shops 스트림에 대한 CompletableFuture 내에서 처리중인 연산이 끝나는 시점.)<br>

<br>

아래는 oracle 공식문서의 내용을 번역해봤다.<br>

> 참고) [docs.oracle.com/.../CompletableFutur/thenCompose](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#thenCompose-java.util.function.Function-)<br>
>
> Description copied from interface: `CompletionStage`<br>
>
> Returns a new CompletionStage that, when this stage completes normally, is executed with this stage as the argument to the supplied function.  See the [`CompletionStage`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) documentation for rules covering exceptional completion.<br>
>
> <br>
>
> 새로운 CompletionStage(CompletableFuture의 원형)를 리턴한다. 이 CompletionStage 인스턴스는 인자로 전달받은 Supplier 를 실행해서 새로운 CompletionStage 인스턴스를 반환한다. 

<br>

뭔가 좀 번역을 해보려 하긴 했는데, 번역은 항상 말이 부자연스러울 수 밖에 없는 듯 하다.<br>

역시 예제를 통해 공부하고, 항상 예를 들어서 기억하는게 오래간다. 예제를 확인해보자.<br>

![이미지](./img/16.4-THEN-COMPOSE.png)

위에서는 첫번째 연산의 결과인 future 를 받아서 future.thenCompose() 하고 있다. 이렇게 future.thenCompose 한 결과 값은 또 다른 비동기 연산이다.<br>

<br>

- thenCompose 메서드 내에는 Supplier 람다를 전달하고 있다.<br>
- 전달하고 있는 Supplier 람다에는 아래와 같은 동작을 기술하고 있다.<br>
  - Supplier 람다로 Discount 클래스 내의 applyDiscount() 함수로 할인율을 조회하는 비동기 스레드인 CompleatableFuture\<String\> 을 생성하는 역할을 하고 있다.

<br>

오늘은 여기까지 일단 정리하기는 했다. 어떻게 여차저차 하면서 정리하다보니 나 자신이 주절주절 쓰게 된것 같다는 생각이 많이 들었다. 내일은 더 명확하게 각 개념 하나 당 3~4 문장 정도로 필요한 말들만 골라서 요약해놓아야 할 것 같다. 물론 다른 공부도 하고.<br>

<br>