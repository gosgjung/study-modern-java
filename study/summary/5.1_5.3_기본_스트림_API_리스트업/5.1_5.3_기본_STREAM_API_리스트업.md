# 5.1 ~ 5.3 기본 STREAM API 리스트업

# 참고자료

아래의 책을 주 교재로 해서 정리를 했다.

- [모던 자바 인 액션](http://www.yes24.com/Product/Goods/78660184?OzSrank=2)



# 들어가기 전에

4장에서는 스트림을 이용해서 외부 반복을 내부 반복으로 바꾸는 방법을 살펴봤다. 아래는 데이터 컬렉션 반복을 명시적으로 관리하는 외부 반복 코드이다.

```java
List <Dish> vegetarianDishes = new ArrayList<>();
for(Dish d: menu){
  if(d.isVegetarian()){
    vegetarianDishes.add(d);
  }
}
```



아래는 명시적 반복 대신 filter, collect 연산을 지원하는 스트림API를 활용해서 내부반복 방식으로 만든 코드이다.

```java
import static java.util.stream.Collectors.toList;

List<Dish> vegetarianDishes = 
  menu.stream()
  	.filter(Dish::isVegetarian)
  	.collect(toList());
```



이 장에서는 스트림 API가 지원하는 다양한 연산을 살펴본다. 자바 8과 자바 9 에서 추가된 다양한 연산을 살펴보고, 필터링,슬라이싱,매핑, 검색, 매칭,리듀싱의 연산의 예제들을 정리해볼 예정이다. 가급적 설명을 제외하고 예제 기반으로 써머리를 해놓을 예정이다.



# 5.1. 필터링 (filter(), distinct())

스트림 인터페이스는 filter 메서드를 지원한다. filter 메서드는 Predicate (boolean 타입을 반환하는 함수)를 인수로 받아서 Predicate와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

- filter()
  - Predicate 기반의 boolean 타입리턴을 통한 필터링연산
- distinct()
  - SQL의 DISTINCT 처럼 중복을 필터링한다.



## 예제 5.1.1) 일반 filter()

```java
List<Dish> vegetarianMenu = menu.stream()
  															.filter(Dish::isVegeterian)
  															.collect(toList());
```



**TODO :: 손그림 사진 추가 필요, 테스트코드 커스터마이징하기**  



## 예제 5.1.2) filter, distinct()

```java
List<Integer> numbers = Arrays.asList(1,2,1,3,3,2,4);
numbers.stream()
  		.filter(i-> i%2 == 0)
  		.distinct()
  		.forEach(System.out::println);
```

  

**TODO :: 손그림 사진 추가 필요, 테스트코드 커스터마이징하기**  



# 5.2. 스트림 슬라이싱 (takeWhile(), dropWhile(), limit(), skip())

아래의 예제는 칼로리가 320 미만인 음식만을 추려내는 예제이다.

```java
List<Dish> specialMenu = Arrays.asList(
  new Dish("seasonal fruit", true, 120, Dish.Type.OTHER),
  new Dish("prawns", true, 300, Dish.Type.FISH),
  new Dish("rice", true, 350, Dish.Type.OTHER),
  new Dish("chicken", true, 400, Dish.Type.MEAT),
  new Dish("french fries", true, 530, Dish.Type.OTHER)
);

List<Dish> filteredMenu
  = specialMenu.stream()
  					.filter(dish -> dish.getCalories() <320)
  					.collect(toList());		// seasonal fruit, prawns 목록
```

만약 filteredMenu가 이미 정렬되어 있다는 것을 보증할 수 있는 데이터라면 컬렉션의 모든 요소를 순회해야 하는 filter() 메서드보다는 **takeWhile()**, **dropWhile()** 등의 연산을 하면 좋다. takeWhile(), dropWhile() 은 java9에서 추가된 메서드이다. 



## takeWhile()

takeWhile() 메서드는 java 9 버전에서부터 추가된 메서드이다.

```java
List<Dish> slicedMenu1
  = specialMenu.stream()
  						.takeWhile(dish -> dish.getCalories() < 320)
  						.collect(toList());
```

specialMenu 라는 이름의 리스트가 정렬되어있다고 가정할 때 칼로리가 320보다 작은 요소가 나왔을때 Stream 내부의 반복순회를 멈추고 collect 하도록 하는 코드이다.  

위와 같은 코드는 작은 리스트에서는 이와 같은 동작이 그리 크게 장점으로 다가오지 않을 수 있지만, 비교적 사이즈가 큰 스트림에서는 상당한 차이를 낼 수 있다.  



## dropWhile()

dropWhile() 메서드는 java 9 버전에서부터 추가된 메서드이다.

```java
List<Dish> slicedMenu2
  = specialMenu.stream()
  						.dropWhile(dish -> dish.getCalories() < 320)
  						.collect(toList());
```

dropWhile은 takeWhile 과는 정반대의 작업을 수행한다. dropWhile()은 프리디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다. **즉, 프리디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 지금까지 순회한 요소들을 collect 해서 반환한다.**



## 스트림 축소 (limit())

SQL 의 LIMIT 연산과 유사한 연산을 하는 코드 역시 작성할 수 있다. 아래의 코드를 보자.

```java
List<Dish> dishes = specialMenu.stream()
  														.filter(dish -> dish.getCalories() > 300)
  														.limit(3)
  														.collect(toList()); // rice, chicken, french fries 목록
```


**TODO :: 손그림 사진 추가 필요, 테스트코드 커스터마이징하기**  



## 요소 건너뛰기 (skip())

컬렉션의 요소가 0,1,2... i, ...n 개 존재한다고 해보자. 이때 skip(2)를 지정하면, 컬렉션의 제일 처음부터 두번째 요소까지는 건너뛰어서 결과를 반환한다.

```java
List<Dish> dishes = menu.stream()
  											.filter(d -> d.getCalories() > 300)
  											.skip(2)
  											.collect(toList());
```



위의 예제는 칼로리가 300 이상인 요리들을 골라내는데, 이렇게 골라내서 얻어낸 데이터의 열에서 처음 두 요리를 건너뛴 후의 그 다음부터의 나머지 요리를 반환한다.



**TODO :: 손그림 사진 추가 필요, 테스트코드 커스터마이징하기**  



# 5.3. 매핑 (map(), flatMap())

매핑함수는 javascript 등을 다루면서도 굉장히 많이 사용하게 되는데, 여기서는 map 함수의 기본개념을 정리하지는 않을 예정이다. 단순 예제로 정리할 예정이다.



## 매핑 (map())

```java
List<String> dishNames = menu.stream()
  													.map(Dish::getName)
  													.collect(toList());
```

List\<Dish\> 타입의 데이터 menu를 각 메뉴의 이름인 Dish::getName 으로 변환하여 반환하고 있다. 데이터의 타입이 Dish에서 String 타입으로 매핑(전환)되었다.  



**TODO :: 테스트코드 커스터마이징하기**  



아래는 또 다른 예제이다.

문자열의 리스트를 각 요소의 길이리스트로 변환하는 예제이다.

**예제 2)**

```java
List<String> words = Arrays.asList("Modern", "Java", "In", "Action");
List<Integer> wordLengths = words.stream()
  															.map(String::length)
  															.collect(toList());
```



**예제 3)**

```java
List<Integer> dishNameLengths = menu.stream()
  																	.map(Dish::getName)
  																	.map(String::length)
  																	.collect(toList());
```



## 스트림 평면화 (flatMap())

flatMap()은 처음 공부하는 사람이라면 이해가 잘 되지 않을 수 있다. (3년전 처음 Java 8 in Action 이라는 책으로 공부할 때 그랬었다.) 이런 이유로 flatMap() 을 사용하지 않을 경우의 코드를 먼저 보고 flatMap()으로 변환하는 코드를 살펴보면 이해가 쉽다.  

flatMap() 은 말로 설명하면 할수록 설명이 이상한 말이 되어버리기 때문에 예제를 보고 직접 실행해보는것이 가장 빠르게 이해하는 방법인 듯하다.

풀어볼 예제는 아래와 같다.

> 문자열 "apple", "banana", "cherry", "world", "mango" 가 있는데, 각각의 이 단어들에 대해서 사용된 알파벳들의 리스트를 추려내보기



## flatMap() 을 사용하지 않을 경우의 예제 (1)

```java
List<String> words = new ArrayList<>();
words.add("apple");
words.add("banana");
words.add("cherry");
words.add("world");
words.add("mango");

List<String[]> destructuredStringList = words.stream()
  .map(word -> word.split(""))
  .distinct()
  .collect(Collectors.toList());
```



예제의 의도는 각 문자열인 {"apple", "banana", "cherry", "world", "mango"} 에 대해서 각 문자열을 분해해서 원자적으로 저장하는 것이다. 즉, 리스트 내에 출연한 출현하게 되는 모든 문자열을 저장하는 것이 목표이다. 하지만 split 메서드는 String [] 을 리턴하기 때문에 원하는 결과를 얻지 못했다.



## flatMap() 을 사용하지 않을 경우의 예제 (2)

map과 Arrays.stream()을 이용해서 List\<String\> 을 변환하는 예제이다.

```java
@Test
void testFlatMapAPI_2_intro(){
  List<String> words = new ArrayList<>();
  words.add("apple");
  words.add("banana");
  words.add("cherry");
  words.add("world");
  words.add("mango");

  List<Stream<String>> destructuredStringList = words.stream()
    .map(word -> word.split(""))
    .map(Arrays::stream)
    .distinct()
    .collect(Collectors.toList());

}
```



스트림 리스트 (List \<Stream\<String\>\>) 가 생성되면서 문제가 깔끔하게 해결되지는 않는다.  

이제 flatMap을 사용하는 예제를 살펴보자.



## flatMap을 사용하는 경우의 예제

```java
@Test
void testFlatMapAPI_3_usingFlatMap(){
  List<String> words = new ArrayList<>();
  words.add("apple");
  words.add("banana");
  words.add("cherry");
  words.add("world");
  words.add("mango");

  List<String> destructuredStringList = words.stream()
    .map(word -> word.split(""))
    .flatMap(Arrays::stream)
    .distinct()
    .sorted()
    .collect(Collectors.toList());

  destructuredStringList.stream().forEach(s->{
    System.out.print(s + " ");
  });
  System.out.println("");
}
```



출력결과

```plain
a b c d e g h l m n o p r w y 
```













