# 64. 기본 접근 한정자를 가진 기능단위 패키지

일반적으로 실무에서는 자주 사용하지 않는 구조이지만 회사를 이직할때 어쩌다 한번씩은 계층별 패키지(`package-by-layer`)라고 하는 것을 사용하는 프로젝트 구조가 어쩌다 한번씩 있다. 계층별 패키지라는 것은 아래와 같은 구조로 패키지들을 설계하는 것이다.<br>

아래같은 구조로 패키지를 구성하는 경우는 거의 없었지만, 우연히 두번 접했는데 정말 끔찍했다. 그 중 첫 번째 경험에서는 다행히도 PL 역할을 하는 과장님이 먼저 제안해주셔서 그분과 함께 신규 프로젝트를 진행하면서 기존 레거시 프로젝트의 패키지 구조를 모두 새로 다시 설계하면서 개발했었다.<br>

<br>

## `package-by-layer` 구조란?

`package-by-layer` 방식으로 패키지를 구성하는 것은 아래와 같은 방식이다.

```java
tld.domain.project.model.Company;
tld.domain.project.model.User;
tld.domain.project.controllers.CompanyController;
tld.domain.project.controllers.UserController;
tld.domain.project.storage.CompanyRepository;
tld.domain.project.storage.UserRepository;
tld.domain.project.service.CompanyService;
tld.domain.project.service.UserService;
```

스프링이나, 서버 애플리케이션에서 보편적으로 이야기하는 기술 또는 기술 스택들의 계층구조로 패키지를 설계한 방식이다.<br>

<br>

## `package-by-layer` 의 단점

**유지보수의 불편함**<br>

이 방식은 일단 다른 단점은 빼더라도 상식 선에서 생각하더라도, 이런 구조는 경험상 나중에 소스코드를 찾아보기가 굉장히 어렵고, 머릿속에 암기해두고 소스코드를 찾아야 했었다.<br>

<br>

**public 키워드를 강제로 사용하게 되는 것으로 인한 오동작가능성 존재**<br>

`package-by-layer` 구조는 모든 기능을 `public` 으로 공개해야 한다는 단점이 있다. <br>

책에서는 특정 Repository 의 메서드를 `public` 으로 공개하는 것에 대한 단점을 설명하고 있다. 특정 Repository의 메서드를 public 으로 공개해 다른 곳에서 바로 다른 서비스의 Repository의 코드를 사용하는 것은 조금 위험하다. DB 접근로직을 재활용할 수 있다는 것은 장점이지만, Service 로직이 아닌, Repository 코드를 재활용함으로써 예기치 못한 에러 및 예외가 발생하는 것이 더 위험하다. (치명적이다.)<br>

<br>

자바는 이런 문제를 해결하기 위해 `접근 한정자(access modifier)`라는 메커니즘을 제공하고 있다. 접근 한정자(access modifier) 키워드는 아래와 같은 것들이 있다.

- private
- protected
- public
- default

<br>

이 중, 접근 제어 한정자 없이 선언한 변수나 메서드는 같은 패키지에 있는 클래스에서만 사용할 수 있다. 이것을 패키지 비공개 (`package-private`) 한정자라고 한다. 위에 정리한 한정자 들 중에서는 흔히 `default` 키워드를 `package-private` 한정자라고 부른다.<br>

<br>

기능단위로 패키지를 구성해 해당 기능의 주요 코드는 패키지 내에서만 사용할 수 있도록 특정 메서드를 `packae-private`, `protected` , `default` 범위로 제한해 사용하는 방식을 `package-by-feature` (기능 단위 패키지) 라고 부른다.<br>

<br>

## `package-by-feature` 구조란 ?

위에서 예로 들었던 `package-by-layer` (계층별 패키지) 구조는 아래와 같은 형태였었다.

```java
tld.domain.project.model.Company;
tld.domain.project.model.User;
tld.domain.project.controllers.CompanyController;
tld.domain.project.controllers.UserController;
tld.domain.project.storage.CompanyRepository;
tld.domain.project.storage.UserRepository;
tld.domain.project.service.CompanyService;
tld.domain.project.service.UserService;
```

<br>

위의 형태를 `package-by-feature` 구조로 정리하면 아래와 같은 모양이 된다.

```java
tld.domain.project.company.Company;
tld.domain.project.company.CompanyController;
tld.domain.project.company.CompanyService;
tld.domain.project.compnay.CompanyRepository;
tld.domain.project.user.User;
tld.domain.project.user.UserController;
tld.domain.project.user.UserService;
tld.domain.project.user.UserRepository;
```

<br>

예를 들면, CompanyService 에서는 UserRepository 내의 changePassword(String) 을 바로 접근하면 안된다. User 에 관련된 서비스는 Company 에 관련된 서비스와는 데이터를 저장하는 순서등이 세부적으로 달라질 수 있기 때문이다.<br>

<br>

## ex) 실제 문제가 될만한 사례

책에서는 뭔가 우아한 예제여서 쉽게 와닿지 않는다. ERP 예제를 들어서 설명했는데 조금은 멋있는 예제라 어렵게 다가온다. 조금은 직관적이고 단순한 예제가 필요하겠다는 생각이 들었고, 직접 따로 예를 들어서 정리해봤다.<br>

예를 들면, 회원에게 공지사항을 보내는 기능을 새로 구현해야 하는 상황이라고 해보자.<br>

회원에게 공지사항을 보낸 후, 공지사항 메일을 보낸 날짜와, 메일 발송성공 여부를 기록하는 insert 로직을 수행해야 하는 상황이다.

- 메일발송
- DB insert
  - 공지사항 메일을 보낸 날짜
  - 메일 발송 성공 여부

메일 발송기능은 회원가입시 인증 메일을 보내는 기능을 이미 만들어둔 상태다. 재활용이 가능하다. 문제는 DB insert 다. 회원가입시 인증 메일을 보내는 기능과 관련된 MailRepository 내의  `insertMailSendHistory(LocalDateTime sendDt, boolean isSuccess)`  를 사용한다고 해보자. (기능별로 분리하지도 않았기에 기능단위 패키지가 아닌 DB 단위 패키지이고, Repository 명도 자세히 보면  `MailRepository` 다.)

> 나머지는 나중에 정리 흐... ㅠㅠ 잤다가 일어나서 시간이 된다면... 흐흐흐... 정리정리