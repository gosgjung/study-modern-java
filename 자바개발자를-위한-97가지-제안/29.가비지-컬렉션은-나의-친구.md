# 29. 가비지 컬렉션은 나의 친구

굉장히 좋은 자료들이 인터넷에 많았고, 깊이 들어가면 세부적으로 알아야 하는 내용들이 있었다. 하지만, 오늘 정리할 때 마음먹은 생각은 아래의 두가지 였다.<br>

- 실무에서 하루 이틀 안에 이번 문서만 보고 가비지컬렉터가 효율적이 되게끔 할 수 있는 힌트를 남겨두자
- 책에서 다루는 주제에서 벗어나면 다른 문서에서 정리하자.

오늘 문서는 이 두 가지 원칙만 지켜서 가능한 짧게 정리할 예정이다.<br>

<br>

> 개인적인 생각<br>
>
> GC가 소비하는 시간을 너무 세세히 최적화할 필요는 없다. GC가 소비하는 시간은 실질적으로 프로그램에 도움이 되기에, GC 속도를 최적화할 필요는 없다. GC를 최적하려기 보다는 GC가 효율적으로 프로그램의 객체를 정리할 수 있도록 코드를 작성하는게 더 애플리케이션의 성능을 끌어올리기 쉬운 방법이다.<br>
>
> 프로그램의 동작을 최적화하려면, GC가 효율적으로 메모리를 관리할 수 있게끔 객체를 선언하는 방식을 바꿔서 코드를 작성해야 한다. 메모리 덤프를 직접 떠보면서 직접 메모리의 추이를 확인해보면서 개선해나가는 것도 좋은 방식 중 하나인 것 같다.<br>

<br>

## Non-JVM 언어들

> 외국에서는 매니지드, 언매니지드 언어, 이렇게도 부르는 것 같다.

가비지 컬렉터가 존재하는 VM 기반 언어들은 대부분 메모리 관리를 VM에서 해준다. 하지만, VM 기반이 아닌 C, C++ 과 같은 언어는 프로그래머가 모두 직접 메모리 할당/해제를 직접 해야 한다.<br>

이렇게 하는 것으로 인해 발생할 수 있는 단점들은 아래와 같다.

- 메모리 누수 : 메모리 해제가 너무 늦어 메모리가 낭비될 경우
- 메모리 크래시 : 메모리 해제를 너무 빨리해서, 존재하지 않는 메모리 주소를 참조하게 된 경우 (ex. 블루스크린... 헛... 이게 맞나? 윽...)

<br>

## VM 언어 - JAVA

JAVA 는 VM 을 사용하는 언어다. 그 중에서도 JVM 을 사용한다. JVM 은 가비지 컬렉터라는 것이 있는데 흔히 GC 라고 부른다. <br>

과거의 JVM의 성능은 현대 JVM 에 비하면 성능이 많이 좋지 않은 편이었고, 자바 GC 는 필요에 의해 지불되어야 하는 비용으로 취급되어 GC 시간의 단축은 가장 보편적인 성능의 가이드라인이었다.<br>

현대의 가비지 컬렉션은 메모리 할당/해제 보다 더 빠르게 동작한다. GC가 실행되고 있는 순간에도 GC의 속도를 높일 수 있다. 즉, 현대의 가비지 컬렉션은 메모리의 할당과 객체의 재정렬도 함께 수행한다.<br>

현대의 가비지 컬렉터는 좋은 메모리 관리 알고리즘의 특성을 모두 갖췄다. 좋은 메모리 관리 알고리즘은 단편화, 경합을 줄여 효과적으로 메모리를 할당하고, 객체를 재정렬해준다. 자바의 가비지 컬렉터는 이런 요소를 갖췄다.<br>

<br>

## 객체 지역성 ( `object locality` )

객체 위치는 애플리케이션 성능에 영향을 준다. 자바의 가비지 컬렉터는 객체를 재정렬 하는 역할과 단편화를 줄여주는 역할을 한다. 자바의 가비지 컬렉터는 동시에 사용하는 것으로 추측되는 객체를 메모리 상에 서로 가깝게 배치하는데, 이것을 `객체 지역성(object locality)` 라고 부른다. `객체 지역성(object locality)` 는 성능 향상에 도움이 된다.<br>

프로그램 실행 시간 대부분을 차지하는 것은 하드웨어에 묶여있거나 메모리 접근을 기다리는 시간이다. 힙 메모리로의 접근은 명령 처리보다 위치적으로 느릴 수 밖에 없다. 따라서 현대의 컴퓨터는 캐시를 사용한다. 프로세서의 캐시에서 객체를 불러오면(fetch) 이웃한 데이터도 함께 가져오게 된다. <br>

<br>

## 효율적인 배치

힙메모리가 파편화 되어 있으면 프로그램이 객체를 생성할 때 충분한 크기의 빈 메모리 공간을 찾는 시간이 오래 걸린다.<br>

<br>

## GC 전략

GC 전략은 JVM 구현체마다 다르며 각 JVM 은 여러 설정 옵션을 제공한다. JVM 기본 값은 보편적으로 큰 문제가 없지만, 몇가지 메커니즘, 설정들을 알아두면 좋다. <br>

예를 들면, 처리량과 응답지연사이에는 어느 정도의 트레이드 오프가 있다. 처리량이 개선되면 응답지연 시간이 늘어나고, 응답지연시간을 줄이면 처리량을 적게 잡아야 한다는 이야기.<br>

<br>

## 스톱 더 월드 (`stop-the-world` ) 컬렉터

스톱 더 월드 컬렉터는 모든 프로그램 동작을 멈추게 한 후에 안전하게 메모리를 수집하는 역할을 한다<br>

<br>

## 동시 (`concurrent`) 컬렉터 

수집 작업을 애플리케이션 스레드에 넘기는데, 전체적인 멈춤 현상은 없다. 대신 각 스레드에서 약간의 지연이 발생한다. 명시적인 멈춤 현상은 없지만, 동시(concurrent) 컬렉터는 스톱 더 월드 컬렉터보다 효율성이 떨어진다. 주로 마우스 재생, GUI 와 같은 애플리케이션 들에게 중요하게 여겨진다.<br>

<br>

## 복사 컬렉터

복사 컬렉터는 힙을 두 영역으로 분리한다. 객체는 '새 공간'에 할당한다. 이 공간이 가득 차면 여기에 할당딘 객체를 예약된 공간으로 복사한 후 메모리 공간을 서로 바꿔치기 한다. 보편적인 워크로드 상에서는 대부분 객체가 이른 시기에 소멸한다. <br>

객체의 수명이 짧으면 복사 단계가 훨씬 빨라진다(복사할 것이 없기 때문이다!)<br>

반면, 객체가 오래 존속하면 수집작업의 효율성이 떨어지게 된다.<br>

복사 컬렉터는 불변 객체에 적합하다.<br>

객체 풀링 '최적화'와는 최악의 궁합을 보인다.<br>

<br>

복사 컬렉터는 힙 메모리를 압축하는데, 근거리 객체할당과 빠른 객체 접근(캐시 미스(`miss`)가 적음)을 제공한다.<br>

> 빠른 객체 접근이라는 것은 결국, 즉, 캐시 미스(`miss`)가 적다는 것을 의미한다.<br>

<br>

## 표시 후 삭제(marking and sweeping) 수집(collect)방식

표시 후 삭제(marking and sweeping) 방식은 힙 메모리를 훑어보고 빈 공간을 확인한 후 그 공간에 새 객체를 할당한다.<br>

<br>